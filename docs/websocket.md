# HTTP (http: https::) -
текстовый протокол для обмена данными между браузером и веб-сервером.
Сервер не знает ничего о клиенте, есть решение cookie.
Пример запроса:
### Метод запроса
    GET             /page.html                      HTTP/1.1
    метод запроса   идентификатор ресурса (uri)     версия протокола
### Заголовки запроса
    Host: site.com
    имя хоста, служебные параметры, кодировки, куки
### Тело запроса (не у всех)
    name=Sergey&last_name=Ivanov&birthday=1990-10-05
    значения полей формы
Пример ответа:
    HTTP/1.1            200 OK
    версия протокола    статус ответа
    Host: site.com
    Content-Type: text/html; charset=UTF-8
    Connection: close
    Content-Length: 21

    <h1>Test page...</h1>
> 200 ОК - успешный запрос, 404 - ресурс не найден на сервере
# Сокет (ws: wss::) - 
это абстракция, которая позволяет работать с сетевыми ресурсами, как с файлами (чтение и запись). И http и websocket отправляют сообщения через tcp (дуплексный протокол). Отправка сообщений одновременная у клиента и сервера. Большие данные фрагментируются на фреймы. 
> Данные можно отправлять в строках, но на деле используют JSON и двоичный
## Этапы:
- клиент отправляет рукопожатие с заголовком обновления (устанавливаем соединение websocket). Установка соединения websocket начинается с обновления http запроса (заголовок с рукопожатием, ключ который генерится каждый раз при рукопожатии)
- запрос отправляется на ws: или wss :: URI
- ответ от сервера об успешном рукопожатии (http код 101)

# Сокеты Беркли (unix)
Функции:
    socket(domain, type, protocol) - конечная точка соединения (возвращает дескриптор). Создание сокетов, ассоциируется с семейством адресов
    connect() - соединение с сервером
    bind() - связываем сокет с конкретным адресом (к прослушиваемому порту)
    listen() - подготавливаем приявязанный сокет к принятию входящих соединений (прослушивание)
    accept() - для принятия запроса на установление соединения от удаленного хоста (можно вызывать несколько раз пока сокет открыт)
> Два процесса не могут использовать один и тот же сокет
    close() - ОБЯЗАТЕЛЬНО (если есть socket(), то должен быть close(), даже если connect() прошел неудачно)
